// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: clientapi.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum AutoControl_Messenger_Type: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case connectRequestType // = 0
  case connectResponseType // = 1
  case authorizationRequestType // = 2
  case authorizationResponseType // = 3
  case pingRequestType // = 4
  case pingResponseType // = 5
  case syncRequestType // = 6
  case syncVehicleResponseType // = 7
  case syncGroupResponseType // = 8
  case syncVehicleSensorResponseType // = 9
  case syncVehicleSensorMessageResponseType // = 10
  case syncDictionaryCompleteResponseType // = 11
  case syncSensorDataResponseType // = 12
  case syncNavigationDataResponseType // = 13
  case syncVehicleDataCompleteResponseType // = 14
  case trackRequestType // = 15
  case trackResponseType // = 16
  case sensorDataEventType // = 17
  case navigationDataEventType // = 18
  case vehicleConnectResponseType // = 19
  case vehicleConnectEventType // = 20
  case syncRouteResponseType // = 21
  case syncBusResponseType // = 22
  case syncPointResponseType // = 23
  case syncBusRequestType // = 24
  case syncPointRequestType // = 25
  case syncEntranceRequestType // = 26
  case syncTimeTablePointRequestType // = 27
  case syncTimeTableRoundRequestType // = 28
  case syncEntranceResponseType // = 29
  case syncTimeTablePointResponseType // = 30
  case syncTimeTableRoundResponseType // = 31

  init() {
    self = .connectRequestType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .connectRequestType
    case 1: self = .connectResponseType
    case 2: self = .authorizationRequestType
    case 3: self = .authorizationResponseType
    case 4: self = .pingRequestType
    case 5: self = .pingResponseType
    case 6: self = .syncRequestType
    case 7: self = .syncVehicleResponseType
    case 8: self = .syncGroupResponseType
    case 9: self = .syncVehicleSensorResponseType
    case 10: self = .syncVehicleSensorMessageResponseType
    case 11: self = .syncDictionaryCompleteResponseType
    case 12: self = .syncSensorDataResponseType
    case 13: self = .syncNavigationDataResponseType
    case 14: self = .syncVehicleDataCompleteResponseType
    case 15: self = .trackRequestType
    case 16: self = .trackResponseType
    case 17: self = .sensorDataEventType
    case 18: self = .navigationDataEventType
    case 19: self = .vehicleConnectResponseType
    case 20: self = .vehicleConnectEventType
    case 21: self = .syncRouteResponseType
    case 22: self = .syncBusResponseType
    case 23: self = .syncPointResponseType
    case 24: self = .syncBusRequestType
    case 25: self = .syncPointRequestType
    case 26: self = .syncEntranceRequestType
    case 27: self = .syncTimeTablePointRequestType
    case 28: self = .syncTimeTableRoundRequestType
    case 29: self = .syncEntranceResponseType
    case 30: self = .syncTimeTablePointResponseType
    case 31: self = .syncTimeTableRoundResponseType
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .connectRequestType: return 0
    case .connectResponseType: return 1
    case .authorizationRequestType: return 2
    case .authorizationResponseType: return 3
    case .pingRequestType: return 4
    case .pingResponseType: return 5
    case .syncRequestType: return 6
    case .syncVehicleResponseType: return 7
    case .syncGroupResponseType: return 8
    case .syncVehicleSensorResponseType: return 9
    case .syncVehicleSensorMessageResponseType: return 10
    case .syncDictionaryCompleteResponseType: return 11
    case .syncSensorDataResponseType: return 12
    case .syncNavigationDataResponseType: return 13
    case .syncVehicleDataCompleteResponseType: return 14
    case .trackRequestType: return 15
    case .trackResponseType: return 16
    case .sensorDataEventType: return 17
    case .navigationDataEventType: return 18
    case .vehicleConnectResponseType: return 19
    case .vehicleConnectEventType: return 20
    case .syncRouteResponseType: return 21
    case .syncBusResponseType: return 22
    case .syncPointResponseType: return 23
    case .syncBusRequestType: return 24
    case .syncPointRequestType: return 25
    case .syncEntranceRequestType: return 26
    case .syncTimeTablePointRequestType: return 27
    case .syncTimeTableRoundRequestType: return 28
    case .syncEntranceResponseType: return 29
    case .syncTimeTablePointResponseType: return 30
    case .syncTimeTableRoundResponseType: return 31
    }
  }

}

#if swift(>=4.2)

extension AutoControl_Messenger_Type: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum AutoControl_Messenger_TypeSensorData: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case intType // = 0
  case stringType // = 1
  case doubleType // = 2
  case boolType // = 3
  case emptyType // = 4

  init() {
    self = .intType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .intType
    case 1: self = .stringType
    case 2: self = .doubleType
    case 3: self = .boolType
    case 4: self = .emptyType
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .intType: return 0
    case .stringType: return 1
    case .doubleType: return 2
    case .boolType: return 3
    case .emptyType: return 4
    }
  }

}

#if swift(>=4.2)

extension AutoControl_Messenger_TypeSensorData: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct AutoControl_Messenger_WrapperMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: AutoControl_Messenger_Type {
    get {return _type ?? .connectRequestType}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var data: Data {
    get {return _data ?? Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var compressed: Bool {
    get {return _compressed ?? false}
    set {_compressed = newValue}
  }
  /// Returns true if `compressed` has been explicitly set.
  var hasCompressed: Bool {return self._compressed != nil}
  /// Clears the value of `compressed`. Subsequent reads from it will return its default value.
  mutating func clearCompressed() {self._compressed = nil}

  var seq: Int32 {
    get {return _seq ?? 0}
    set {_seq = newValue}
  }
  /// Returns true if `seq` has been explicitly set.
  var hasSeq: Bool {return self._seq != nil}
  /// Clears the value of `seq`. Subsequent reads from it will return its default value.
  mutating func clearSeq() {self._seq = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: AutoControl_Messenger_Type? = nil
  fileprivate var _data: Data? = nil
  fileprivate var _compressed: Bool? = nil
  fileprivate var _seq: Int32? = nil
}

struct AutoControl_Messenger_ConnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `protocol`: Int32 {
    get {return _protocol ?? 0}
    set {_protocol = newValue}
  }
  /// Returns true if ``protocol`` has been explicitly set.
  var hasProtocol: Bool {return self._protocol != nil}
  /// Clears the value of ``protocol``. Subsequent reads from it will return its default value.
  mutating func clearProtocol() {self._protocol = nil}

  var clientType: Int32 {
    get {return _clientType ?? 0}
    set {_clientType = newValue}
  }
  /// Returns true if `clientType` has been explicitly set.
  var hasClientType: Bool {return self._clientType != nil}
  /// Clears the value of `clientType`. Subsequent reads from it will return its default value.
  mutating func clearClientType() {self._clientType = nil}

  var clientVersion: Data {
    get {return _clientVersion ?? Data()}
    set {_clientVersion = newValue}
  }
  /// Returns true if `clientVersion` has been explicitly set.
  var hasClientVersion: Bool {return self._clientVersion != nil}
  /// Clears the value of `clientVersion`. Subsequent reads from it will return its default value.
  mutating func clearClientVersion() {self._clientVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _protocol: Int32? = nil
  fileprivate var _clientType: Int32? = nil
  fileprivate var _clientVersion: Data? = nil
}

struct AutoControl_Messenger_ConnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Int32 {
    get {return _status ?? 0}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var sessionID: Int32 {
    get {return _sessionID ?? 0}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  mutating func clearSessionID() {self._sessionID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _status: Int32? = nil
  fileprivate var _sessionID: Int32? = nil
}

struct AutoControl_Messenger_AuthorizationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var login: String {
    get {return _login ?? String()}
    set {_login = newValue}
  }
  /// Returns true if `login` has been explicitly set.
  var hasLogin: Bool {return self._login != nil}
  /// Clears the value of `login`. Subsequent reads from it will return its default value.
  mutating func clearLogin() {self._login = nil}

  var password: String {
    get {return _password ?? String()}
    set {_password = newValue}
  }
  /// Returns true if `password` has been explicitly set.
  var hasPassword: Bool {return self._password != nil}
  /// Clears the value of `password`. Subsequent reads from it will return its default value.
  mutating func clearPassword() {self._password = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _login: String? = nil
  fileprivate var _password: String? = nil
}

struct AutoControl_Messenger_AuthorizationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Int32 {
    get {return _state ?? 0}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var permissions: [AutoControl_Messenger_PermissionProtoObject] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: Int32? = nil
  fileprivate var _name: String? = nil
}

struct AutoControl_Messenger_PermissionProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var value: Int32 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _value: Int32? = nil
}

struct AutoControl_Messenger_PingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fake: Int32 {
    get {return _fake ?? 0}
    set {_fake = newValue}
  }
  /// Returns true if `fake` has been explicitly set.
  var hasFake: Bool {return self._fake != nil}
  /// Clears the value of `fake`. Subsequent reads from it will return its default value.
  mutating func clearFake() {self._fake = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fake: Int32? = nil
}

struct AutoControl_Messenger_PingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fake: Int32 {
    get {return _fake ?? 0}
    set {_fake = newValue}
  }
  /// Returns true if `fake` has been explicitly set.
  var hasFake: Bool {return self._fake != nil}
  /// Clears the value of `fake`. Subsequent reads from it will return its default value.
  mutating func clearFake() {self._fake = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fake: Int32? = nil
}

struct AutoControl_Messenger_SyncRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///sec after 01.01.1970 UTC
  var lastSyncTime: Int64 {
    get {return _lastSyncTime ?? 0}
    set {_lastSyncTime = newValue}
  }
  /// Returns true if `lastSyncTime` has been explicitly set.
  var hasLastSyncTime: Bool {return self._lastSyncTime != nil}
  /// Clears the value of `lastSyncTime`. Subsequent reads from it will return its default value.
  mutating func clearLastSyncTime() {self._lastSyncTime = nil}

  var existRouteID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastSyncTime: Int64? = nil
}

struct AutoControl_Messenger_SyncBusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///sec after 01.01.1970 UTC
  var lastSyncTime: Int64 {
    get {return _lastSyncTime ?? 0}
    set {_lastSyncTime = newValue}
  }
  /// Returns true if `lastSyncTime` has been explicitly set.
  var hasLastSyncTime: Bool {return self._lastSyncTime != nil}
  /// Clears the value of `lastSyncTime`. Subsequent reads from it will return its default value.
  mutating func clearLastSyncTime() {self._lastSyncTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastSyncTime: Int64? = nil
}

struct AutoControl_Messenger_SyncPointRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///sec after 01.01.1970 UTC
  var lastSyncTime: Int64 {
    get {return _lastSyncTime ?? 0}
    set {_lastSyncTime = newValue}
  }
  /// Returns true if `lastSyncTime` has been explicitly set.
  var hasLastSyncTime: Bool {return self._lastSyncTime != nil}
  /// Clears the value of `lastSyncTime`. Subsequent reads from it will return its default value.
  mutating func clearLastSyncTime() {self._lastSyncTime = nil}

  var existPointID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastSyncTime: Int64? = nil
}

struct AutoControl_Messenger_SyncEntranceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///sec after 01.01.1970 UTC
  var lastSyncTime: Int64 {
    get {return _lastSyncTime ?? 0}
    set {_lastSyncTime = newValue}
  }
  /// Returns true if `lastSyncTime` has been explicitly set.
  var hasLastSyncTime: Bool {return self._lastSyncTime != nil}
  /// Clears the value of `lastSyncTime`. Subsequent reads from it will return its default value.
  mutating func clearLastSyncTime() {self._lastSyncTime = nil}

  var existEntranceID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastSyncTime: Int64? = nil
}

struct AutoControl_Messenger_SyncTimeTablePointRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///sec after 01.01.1970 UTC
  var lastSyncTime: Int64 {
    get {return _lastSyncTime ?? 0}
    set {_lastSyncTime = newValue}
  }
  /// Returns true if `lastSyncTime` has been explicitly set.
  var hasLastSyncTime: Bool {return self._lastSyncTime != nil}
  /// Clears the value of `lastSyncTime`. Subsequent reads from it will return its default value.
  mutating func clearLastSyncTime() {self._lastSyncTime = nil}

  var existTimeTablePointID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastSyncTime: Int64? = nil
}

struct AutoControl_Messenger_SyncTimeTableRoundRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///sec after 01.01.1970 UTC
  var lastSyncTime: Int64 {
    get {return _lastSyncTime ?? 0}
    set {_lastSyncTime = newValue}
  }
  /// Returns true if `lastSyncTime` has been explicitly set.
  var hasLastSyncTime: Bool {return self._lastSyncTime != nil}
  /// Clears the value of `lastSyncTime`. Subsequent reads from it will return its default value.
  mutating func clearLastSyncTime() {self._lastSyncTime = nil}

  var existTimeTableRoundID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastSyncTime: Int64? = nil
}

struct AutoControl_Messenger_SyncVehicleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicle: [AutoControl_Messenger_VehicleProtoObject] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_VehicleProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var groupID: Int32 {
    get {return _groupID ?? 0}
    set {_groupID = newValue}
  }
  /// Returns true if `groupID` has been explicitly set.
  var hasGroupID: Bool {return self._groupID != nil}
  /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
  mutating func clearGroupID() {self._groupID = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var vin: String {
    get {return _vin ?? String()}
    set {_vin = newValue}
  }
  /// Returns true if `vin` has been explicitly set.
  var hasVin: Bool {return self._vin != nil}
  /// Clears the value of `vin`. Subsequent reads from it will return its default value.
  mutating func clearVin() {self._vin = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _groupID: Int32? = nil
  fileprivate var _name: String? = nil
  fileprivate var _vin: String? = nil
}

struct AutoControl_Messenger_SyncGroupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: [AutoControl_Messenger_GroupProtoObject] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_GroupProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _name: String? = nil
}

struct AutoControl_Messenger_SyncVehicleSensorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleSensor: [AutoControl_Messenger_VehicleSensorProtoObject] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_VehicleSensorProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///vehicle_sensor_id
  var id: Int32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var vehicleID: Int32 {
    get {return _vehicleID ?? 0}
    set {_vehicleID = newValue}
  }
  /// Returns true if `vehicleID` has been explicitly set.
  var hasVehicleID: Bool {return self._vehicleID != nil}
  /// Clears the value of `vehicleID`. Subsequent reads from it will return its default value.
  mutating func clearVehicleID() {self._vehicleID = nil}

  var sensorType: Int32 {
    get {return _sensorType ?? 0}
    set {_sensorType = newValue}
  }
  /// Returns true if `sensorType` has been explicitly set.
  var hasSensorType: Bool {return self._sensorType != nil}
  /// Clears the value of `sensorType`. Subsequent reads from it will return its default value.
  mutating func clearSensorType() {self._sensorType = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _vehicleID: Int32? = nil
  fileprivate var _sensorType: Int32? = nil
  fileprivate var _name: String? = nil
}

struct AutoControl_Messenger_SyncVehicleSensorMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sensorMessage: [AutoControl_Messenger_SensorMessageProtoObject] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_SensorMessageProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Int32 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  var vehicleSensorID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Int32? = nil
  fileprivate var _text: String? = nil
}

struct AutoControl_Messenger_SyncDictionaryCompleteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///sec after 01.01.1970 UTC
  var lastSyncTime: Int64 {
    get {return _lastSyncTime ?? 0}
    set {_lastSyncTime = newValue}
  }
  /// Returns true if `lastSyncTime` has been explicitly set.
  var hasLastSyncTime: Bool {return self._lastSyncTime != nil}
  /// Clears the value of `lastSyncTime`. Subsequent reads from it will return its default value.
  mutating func clearLastSyncTime() {self._lastSyncTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastSyncTime: Int64? = nil
}

struct AutoControl_Messenger_SyncSensorDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: [AutoControl_Messenger_SensorDataProtoObject] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_SensorDataProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleSensorID: Int32 {
    get {return _vehicleSensorID ?? 0}
    set {_vehicleSensorID = newValue}
  }
  /// Returns true if `vehicleSensorID` has been explicitly set.
  var hasVehicleSensorID: Bool {return self._vehicleSensorID != nil}
  /// Clears the value of `vehicleSensorID`. Subsequent reads from it will return its default value.
  mutating func clearVehicleSensorID() {self._vehicleSensorID = nil}

  var dateTime: Int64 {
    get {return _dateTime ?? 0}
    set {_dateTime = newValue}
  }
  /// Returns true if `dateTime` has been explicitly set.
  var hasDateTime: Bool {return self._dateTime != nil}
  /// Clears the value of `dateTime`. Subsequent reads from it will return its default value.
  mutating func clearDateTime() {self._dateTime = nil}

  var typeSensorData: AutoControl_Messenger_TypeSensorData {
    get {return _typeSensorData ?? .intType}
    set {_typeSensorData = newValue}
  }
  /// Returns true if `typeSensorData` has been explicitly set.
  var hasTypeSensorData: Bool {return self._typeSensorData != nil}
  /// Clears the value of `typeSensorData`. Subsequent reads from it will return its default value.
  mutating func clearTypeSensorData() {self._typeSensorData = nil}

  var valueInt: Int32 {
    get {return _valueInt ?? 0}
    set {_valueInt = newValue}
  }
  /// Returns true if `valueInt` has been explicitly set.
  var hasValueInt: Bool {return self._valueInt != nil}
  /// Clears the value of `valueInt`. Subsequent reads from it will return its default value.
  mutating func clearValueInt() {self._valueInt = nil}

  var valueDouble: Double {
    get {return _valueDouble ?? 0}
    set {_valueDouble = newValue}
  }
  /// Returns true if `valueDouble` has been explicitly set.
  var hasValueDouble: Bool {return self._valueDouble != nil}
  /// Clears the value of `valueDouble`. Subsequent reads from it will return its default value.
  mutating func clearValueDouble() {self._valueDouble = nil}

  var valueString: String {
    get {return _valueString ?? String()}
    set {_valueString = newValue}
  }
  /// Returns true if `valueString` has been explicitly set.
  var hasValueString: Bool {return self._valueString != nil}
  /// Clears the value of `valueString`. Subsequent reads from it will return its default value.
  mutating func clearValueString() {self._valueString = nil}

  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vehicleSensorID: Int32? = nil
  fileprivate var _dateTime: Int64? = nil
  fileprivate var _typeSensorData: AutoControl_Messenger_TypeSensorData? = nil
  fileprivate var _valueInt: Int32? = nil
  fileprivate var _valueDouble: Double? = nil
  fileprivate var _valueString: String? = nil
  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
}

struct AutoControl_Messenger_SyncNavigationDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: [AutoControl_Messenger_SyncNavigationDataProtoObject] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_SyncNavigationDataProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleID: Int32 {
    get {return _vehicleID ?? 0}
    set {_vehicleID = newValue}
  }
  /// Returns true if `vehicleID` has been explicitly set.
  var hasVehicleID: Bool {return self._vehicleID != nil}
  /// Clears the value of `vehicleID`. Subsequent reads from it will return its default value.
  mutating func clearVehicleID() {self._vehicleID = nil}

  var data: AutoControl_Messenger_NavigationDataProtoObject {
    get {return _data ?? AutoControl_Messenger_NavigationDataProtoObject()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vehicleID: Int32? = nil
  fileprivate var _data: AutoControl_Messenger_NavigationDataProtoObject? = nil
}

struct AutoControl_Messenger_NavigationDataProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dateTime: Int64 {
    get {return _dateTime ?? 0}
    set {_dateTime = newValue}
  }
  /// Returns true if `dateTime` has been explicitly set.
  var hasDateTime: Bool {return self._dateTime != nil}
  /// Clears the value of `dateTime`. Subsequent reads from it will return its default value.
  mutating func clearDateTime() {self._dateTime = nil}

  var valid: Bool {
    get {return _valid ?? false}
    set {_valid = newValue}
  }
  /// Returns true if `valid` has been explicitly set.
  var hasValid: Bool {return self._valid != nil}
  /// Clears the value of `valid`. Subsequent reads from it will return its default value.
  mutating func clearValid() {self._valid = nil}

  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var speed: Double {
    get {return _speed ?? 0}
    set {_speed = newValue}
  }
  /// Returns true if `speed` has been explicitly set.
  var hasSpeed: Bool {return self._speed != nil}
  /// Clears the value of `speed`. Subsequent reads from it will return its default value.
  mutating func clearSpeed() {self._speed = nil}

  var course: Double {
    get {return _course ?? 0}
    set {_course = newValue}
  }
  /// Returns true if `course` has been explicitly set.
  var hasCourse: Bool {return self._course != nil}
  /// Clears the value of `course`. Subsequent reads from it will return its default value.
  mutating func clearCourse() {self._course = nil}

  var delta: Double {
    get {return _delta ?? 0}
    set {_delta = newValue}
  }
  /// Returns true if `delta` has been explicitly set.
  var hasDelta: Bool {return self._delta != nil}
  /// Clears the value of `delta`. Subsequent reads from it will return its default value.
  mutating func clearDelta() {self._delta = nil}

  var satelliteCount: Int32 {
    get {return _satelliteCount ?? 0}
    set {_satelliteCount = newValue}
  }
  /// Returns true if `satelliteCount` has been explicitly set.
  var hasSatelliteCount: Bool {return self._satelliteCount != nil}
  /// Clears the value of `satelliteCount`. Subsequent reads from it will return its default value.
  mutating func clearSatelliteCount() {self._satelliteCount = nil}

  var height: Int32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var hdop: Int32 {
    get {return _hdop ?? 0}
    set {_hdop = newValue}
  }
  /// Returns true if `hdop` has been explicitly set.
  var hasHdop: Bool {return self._hdop != nil}
  /// Clears the value of `hdop`. Subsequent reads from it will return its default value.
  mutating func clearHdop() {self._hdop = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dateTime: Int64? = nil
  fileprivate var _valid: Bool? = nil
  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
  fileprivate var _speed: Double? = nil
  fileprivate var _course: Double? = nil
  fileprivate var _delta: Double? = nil
  fileprivate var _satelliteCount: Int32? = nil
  fileprivate var _height: Int32? = nil
  fileprivate var _hdop: Int32? = nil
}

struct AutoControl_Messenger_SyncRouteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var route: [AutoControl_Messenger_RouteProtoObject] = []

  var deletedRouteID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_RouteProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var wkt: String {
    get {return _wkt ?? String()}
    set {_wkt = newValue}
  }
  /// Returns true if `wkt` has been explicitly set.
  var hasWkt: Bool {return self._wkt != nil}
  /// Clears the value of `wkt`. Subsequent reads from it will return its default value.
  mutating func clearWkt() {self._wkt = nil}

  var enabled: Bool {
    get {return _enabled ?? false}
    set {_enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  var hasEnabled: Bool {return self._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  mutating func clearEnabled() {self._enabled = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _name: String? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _wkt: String? = nil
  fileprivate var _enabled: Bool? = nil
}

struct AutoControl_Messenger_SyncBusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bus: [AutoControl_Messenger_BusProtoObject] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_BusProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var speed: Double {
    get {return _speed ?? 0}
    set {_speed = newValue}
  }
  /// Returns true if `speed` has been explicitly set.
  var hasSpeed: Bool {return self._speed != nil}
  /// Clears the value of `speed`. Subsequent reads from it will return its default value.
  mutating func clearSpeed() {self._speed = nil}

  var course: Double {
    get {return _course ?? 0}
    set {_course = newValue}
  }
  /// Returns true if `course` has been explicitly set.
  var hasCourse: Bool {return self._course != nil}
  /// Clears the value of `course`. Subsequent reads from it will return its default value.
  mutating func clearCourse() {self._course = nil}

  var date: Int64 {
    get {return _date ?? 0}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var routeID: Int32 {
    get {return _routeID ?? 0}
    set {_routeID = newValue}
  }
  /// Returns true if `routeID` has been explicitly set.
  var hasRouteID: Bool {return self._routeID != nil}
  /// Clears the value of `routeID`. Subsequent reads from it will return its default value.
  mutating func clearRouteID() {self._routeID = nil}

  var entranceID: Int32 {
    get {return _entranceID ?? 0}
    set {_entranceID = newValue}
  }
  /// Returns true if `entranceID` has been explicitly set.
  var hasEntranceID: Bool {return self._entranceID != nil}
  /// Clears the value of `entranceID`. Subsequent reads from it will return its default value.
  mutating func clearEntranceID() {self._entranceID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _name: String? = nil
  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
  fileprivate var _speed: Double? = nil
  fileprivate var _course: Double? = nil
  fileprivate var _date: Int64? = nil
  fileprivate var _routeID: Int32? = nil
  fileprivate var _entranceID: Int32? = nil
}

struct AutoControl_Messenger_SyncEntranceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entrance: [AutoControl_Messenger_EntranceProtoObject] = []

  var deletedEntranceID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_EntranceProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _name: String? = nil
}

struct AutoControl_Messenger_SyncTimeTablePointResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timetablePoint: [AutoControl_Messenger_TimeTablePointProtoObject] = []

  var deletedTimeTablePointID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_TimeTablePointProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var routePointID: Int32 {
    get {return _routePointID ?? 0}
    set {_routePointID = newValue}
  }
  /// Returns true if `routePointID` has been explicitly set.
  var hasRoutePointID: Bool {return self._routePointID != nil}
  /// Clears the value of `routePointID`. Subsequent reads from it will return its default value.
  mutating func clearRoutePointID() {self._routePointID = nil}

  var entranceID: Int32 {
    get {return _entranceID ?? 0}
    set {_entranceID = newValue}
  }
  /// Returns true if `entranceID` has been explicitly set.
  var hasEntranceID: Bool {return self._entranceID != nil}
  /// Clears the value of `entranceID`. Subsequent reads from it will return its default value.
  mutating func clearEntranceID() {self._entranceID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _routePointID: Int32? = nil
  fileprivate var _entranceID: Int32? = nil
}

struct AutoControl_Messenger_SyncTimeTableRoundResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timetableRound: [AutoControl_Messenger_TimeTableRoundProtoObject] = []

  var deletedTimeTableRoundID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_TimeTableRoundProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var timeTablePointID: Int32 {
    get {return _timeTablePointID ?? 0}
    set {_timeTablePointID = newValue}
  }
  /// Returns true if `timeTablePointID` has been explicitly set.
  var hasTimeTablePointID: Bool {return self._timeTablePointID != nil}
  /// Clears the value of `timeTablePointID`. Subsequent reads from it will return its default value.
  mutating func clearTimeTablePointID() {self._timeTablePointID = nil}

  var round: Int32 {
    get {return _round ?? 0}
    set {_round = newValue}
  }
  /// Returns true if `round` has been explicitly set.
  var hasRound: Bool {return self._round != nil}
  /// Clears the value of `round`. Subsequent reads from it will return its default value.
  mutating func clearRound() {self._round = nil}

  var time: Int64 {
    get {return _time ?? 0}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _timeTablePointID: Int32? = nil
  fileprivate var _round: Int32? = nil
  fileprivate var _time: Int64? = nil
}

struct AutoControl_Messenger_SyncPointResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var point: [AutoControl_Messenger_PointProtoObject] = []

  var deletedPointID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_PointProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var routeID: Int32 {
    get {return _routeID ?? 0}
    set {_routeID = newValue}
  }
  /// Returns true if `routeID` has been explicitly set.
  var hasRouteID: Bool {return self._routeID != nil}
  /// Clears the value of `routeID`. Subsequent reads from it will return its default value.
  mutating func clearRouteID() {self._routeID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _name: String? = nil
  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
  fileprivate var _routeID: Int32? = nil
}

struct AutoControl_Messenger_SyncVehicleDataCompleteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fake: Int32 {
    get {return _fake ?? 0}
    set {_fake = newValue}
  }
  /// Returns true if `fake` has been explicitly set.
  var hasFake: Bool {return self._fake != nil}
  /// Clears the value of `fake`. Subsequent reads from it will return its default value.
  mutating func clearFake() {self._fake = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fake: Int32? = nil
}

struct AutoControl_Messenger_TrackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleID: Int32 {
    get {return _vehicleID ?? 0}
    set {_vehicleID = newValue}
  }
  /// Returns true if `vehicleID` has been explicitly set.
  var hasVehicleID: Bool {return self._vehicleID != nil}
  /// Clears the value of `vehicleID`. Subsequent reads from it will return its default value.
  mutating func clearVehicleID() {self._vehicleID = nil}

  var dateTimeFrom: Int64 {
    get {return _dateTimeFrom ?? 0}
    set {_dateTimeFrom = newValue}
  }
  /// Returns true if `dateTimeFrom` has been explicitly set.
  var hasDateTimeFrom: Bool {return self._dateTimeFrom != nil}
  /// Clears the value of `dateTimeFrom`. Subsequent reads from it will return its default value.
  mutating func clearDateTimeFrom() {self._dateTimeFrom = nil}

  var dateTimeTo: Int64 {
    get {return _dateTimeTo ?? 0}
    set {_dateTimeTo = newValue}
  }
  /// Returns true if `dateTimeTo` has been explicitly set.
  var hasDateTimeTo: Bool {return self._dateTimeTo != nil}
  /// Clears the value of `dateTimeTo`. Subsequent reads from it will return its default value.
  mutating func clearDateTimeTo() {self._dateTimeTo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vehicleID: Int32? = nil
  fileprivate var _dateTimeFrom: Int64? = nil
  fileprivate var _dateTimeTo: Int64? = nil
}

struct AutoControl_Messenger_TrackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleID: Int32 {
    get {return _vehicleID ?? 0}
    set {_vehicleID = newValue}
  }
  /// Returns true if `vehicleID` has been explicitly set.
  var hasVehicleID: Bool {return self._vehicleID != nil}
  /// Clears the value of `vehicleID`. Subsequent reads from it will return its default value.
  mutating func clearVehicleID() {self._vehicleID = nil}

  var data: [AutoControl_Messenger_TrackProtoObject] = []

  var currentNumberEvent: Int32 {
    get {return _currentNumberEvent ?? 0}
    set {_currentNumberEvent = newValue}
  }
  /// Returns true if `currentNumberEvent` has been explicitly set.
  var hasCurrentNumberEvent: Bool {return self._currentNumberEvent != nil}
  /// Clears the value of `currentNumberEvent`. Subsequent reads from it will return its default value.
  mutating func clearCurrentNumberEvent() {self._currentNumberEvent = nil}

  var totalAmountEvent: Int32 {
    get {return _totalAmountEvent ?? 0}
    set {_totalAmountEvent = newValue}
  }
  /// Returns true if `totalAmountEvent` has been explicitly set.
  var hasTotalAmountEvent: Bool {return self._totalAmountEvent != nil}
  /// Clears the value of `totalAmountEvent`. Subsequent reads from it will return its default value.
  mutating func clearTotalAmountEvent() {self._totalAmountEvent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vehicleID: Int32? = nil
  fileprivate var _currentNumberEvent: Int32? = nil
  fileprivate var _totalAmountEvent: Int32? = nil
}

struct AutoControl_Messenger_TrackProtoObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sensorData: AutoControl_Messenger_SensorDataProtoObject {
    get {return _storage._sensorData ?? AutoControl_Messenger_SensorDataProtoObject()}
    set {_uniqueStorage()._sensorData = newValue}
  }
  /// Returns true if `sensorData` has been explicitly set.
  var hasSensorData: Bool {return _storage._sensorData != nil}
  /// Clears the value of `sensorData`. Subsequent reads from it will return its default value.
  mutating func clearSensorData() {_uniqueStorage()._sensorData = nil}

  var navigationData: AutoControl_Messenger_NavigationDataProtoObject {
    get {return _storage._navigationData ?? AutoControl_Messenger_NavigationDataProtoObject()}
    set {_uniqueStorage()._navigationData = newValue}
  }
  /// Returns true if `navigationData` has been explicitly set.
  var hasNavigationData: Bool {return _storage._navigationData != nil}
  /// Clears the value of `navigationData`. Subsequent reads from it will return its default value.
  mutating func clearNavigationData() {_uniqueStorage()._navigationData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct AutoControl_Messenger_SensorDataEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: AutoControl_Messenger_SensorDataProtoObject {
    get {return _data ?? AutoControl_Messenger_SensorDataProtoObject()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _data: AutoControl_Messenger_SensorDataProtoObject? = nil
}

struct AutoControl_Messenger_NavigationDataEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleID: Int32 {
    get {return _vehicleID ?? 0}
    set {_vehicleID = newValue}
  }
  /// Returns true if `vehicleID` has been explicitly set.
  var hasVehicleID: Bool {return self._vehicleID != nil}
  /// Clears the value of `vehicleID`. Subsequent reads from it will return its default value.
  mutating func clearVehicleID() {self._vehicleID = nil}

  var data: AutoControl_Messenger_NavigationDataProtoObject {
    get {return _data ?? AutoControl_Messenger_NavigationDataProtoObject()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vehicleID: Int32? = nil
  fileprivate var _data: AutoControl_Messenger_NavigationDataProtoObject? = nil
}

struct AutoControl_Messenger_VehicleConnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: [AutoControl_Messenger_VehicleConnectEvent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AutoControl_Messenger_VehicleConnectEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleID: Int32 {
    get {return _vehicleID ?? 0}
    set {_vehicleID = newValue}
  }
  /// Returns true if `vehicleID` has been explicitly set.
  var hasVehicleID: Bool {return self._vehicleID != nil}
  /// Clears the value of `vehicleID`. Subsequent reads from it will return its default value.
  mutating func clearVehicleID() {self._vehicleID = nil}

  var connect: Bool {
    get {return _connect ?? false}
    set {_connect = newValue}
  }
  /// Returns true if `connect` has been explicitly set.
  var hasConnect: Bool {return self._connect != nil}
  /// Clears the value of `connect`. Subsequent reads from it will return its default value.
  mutating func clearConnect() {self._connect = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vehicleID: Int32? = nil
  fileprivate var _connect: Bool? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "AutoControl.Messenger"

extension AutoControl_Messenger_Type: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ConnectRequestType"),
    1: .same(proto: "ConnectResponseType"),
    2: .same(proto: "AuthorizationRequestType"),
    3: .same(proto: "AuthorizationResponseType"),
    4: .same(proto: "PingRequestType"),
    5: .same(proto: "PingResponseType"),
    6: .same(proto: "SyncRequestType"),
    7: .same(proto: "SyncVehicleResponseType"),
    8: .same(proto: "SyncGroupResponseType"),
    9: .same(proto: "SyncVehicleSensorResponseType"),
    10: .same(proto: "SyncVehicleSensorMessageResponseType"),
    11: .same(proto: "SyncDictionaryCompleteResponseType"),
    12: .same(proto: "SyncSensorDataResponseType"),
    13: .same(proto: "SyncNavigationDataResponseType"),
    14: .same(proto: "SyncVehicleDataCompleteResponseType"),
    15: .same(proto: "TrackRequestType"),
    16: .same(proto: "TrackResponseType"),
    17: .same(proto: "SensorDataEventType"),
    18: .same(proto: "NavigationDataEventType"),
    19: .same(proto: "VehicleConnectResponseType"),
    20: .same(proto: "VehicleConnectEventType"),
    21: .same(proto: "SyncRouteResponseType"),
    22: .same(proto: "SyncBusResponseType"),
    23: .same(proto: "SyncPointResponseType"),
    24: .same(proto: "SyncBusRequestType"),
    25: .same(proto: "SyncPointRequestType"),
    26: .same(proto: "SyncEntranceRequestType"),
    27: .same(proto: "SyncTimeTablePointRequestType"),
    28: .same(proto: "SyncTimeTableRoundRequestType"),
    29: .same(proto: "SyncEntranceResponseType"),
    30: .same(proto: "SyncTimeTablePointResponseType"),
    31: .same(proto: "SyncTimeTableRoundResponseType"),
  ]
}

extension AutoControl_Messenger_TypeSensorData: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "intType"),
    1: .same(proto: "stringType"),
    2: .same(proto: "doubleType"),
    3: .same(proto: "boolType"),
    4: .same(proto: "emptyType"),
  ]
}

extension AutoControl_Messenger_WrapperMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WrapperMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "data"),
    3: .same(proto: "compressed"),
    4: .same(proto: "seq"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._data == nil {return false}
    if self._compressed == nil {return false}
    if self._seq == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._data) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._compressed) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._seq) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._compressed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._seq {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_WrapperMessage, rhs: AutoControl_Messenger_WrapperMessage) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._data != rhs._data {return false}
    if lhs._compressed != rhs._compressed {return false}
    if lhs._seq != rhs._seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protocol"),
    2: .same(proto: "clientType"),
    3: .same(proto: "clientVersion"),
  ]

  public var isInitialized: Bool {
    if self._protocol == nil {return false}
    if self._clientType == nil {return false}
    if self._clientVersion == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._protocol) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._clientType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._clientVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._protocol {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._clientType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._clientVersion {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_ConnectRequest, rhs: AutoControl_Messenger_ConnectRequest) -> Bool {
    if lhs._protocol != rhs._protocol {return false}
    if lhs._clientType != rhs._clientType {return false}
    if lhs._clientVersion != rhs._clientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "sessionId"),
  ]

  public var isInitialized: Bool {
    if self._status == nil {return false}
    if self._sessionID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._status) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._sessionID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_ConnectResponse, rhs: AutoControl_Messenger_ConnectResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_AuthorizationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "login"),
    2: .same(proto: "password"),
  ]

  public var isInitialized: Bool {
    if self._login == nil {return false}
    if self._password == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._login) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._login {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._password {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_AuthorizationRequest, rhs: AutoControl_Messenger_AuthorizationRequest) -> Bool {
    if lhs._login != rhs._login {return false}
    if lhs._password != rhs._password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_AuthorizationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "name"),
    3: .same(proto: "permissions"),
  ]

  public var isInitialized: Bool {
    if self._state == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.permissions) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._state) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.permissions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._state {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.permissions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_AuthorizationResponse, rhs: AutoControl_Messenger_AuthorizationResponse) -> Bool {
    if lhs._state != rhs._state {return false}
    if lhs._name != rhs._name {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_PermissionProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PermissionProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._value == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_PermissionProtoObject, rhs: AutoControl_Messenger_PermissionProtoObject) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_PingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fake"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._fake) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fake {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_PingRequest, rhs: AutoControl_Messenger_PingRequest) -> Bool {
    if lhs._fake != rhs._fake {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_PingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fake"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._fake) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fake {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_PingResponse, rhs: AutoControl_Messenger_PingResponse) -> Bool {
    if lhs._fake != rhs._fake {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSyncTime"),
    2: .same(proto: "existRouteId"),
  ]

  public var isInitialized: Bool {
    if self._lastSyncTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._lastSyncTime) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.existRouteID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._lastSyncTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if !self.existRouteID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.existRouteID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncRequest, rhs: AutoControl_Messenger_SyncRequest) -> Bool {
    if lhs._lastSyncTime != rhs._lastSyncTime {return false}
    if lhs.existRouteID != rhs.existRouteID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncBusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncBusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSyncTime"),
  ]

  public var isInitialized: Bool {
    if self._lastSyncTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._lastSyncTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._lastSyncTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncBusRequest, rhs: AutoControl_Messenger_SyncBusRequest) -> Bool {
    if lhs._lastSyncTime != rhs._lastSyncTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncPointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncPointRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSyncTime"),
    2: .same(proto: "existPointId"),
  ]

  public var isInitialized: Bool {
    if self._lastSyncTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._lastSyncTime) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.existPointID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._lastSyncTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if !self.existPointID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.existPointID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncPointRequest, rhs: AutoControl_Messenger_SyncPointRequest) -> Bool {
    if lhs._lastSyncTime != rhs._lastSyncTime {return false}
    if lhs.existPointID != rhs.existPointID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncEntranceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncEntranceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSyncTime"),
    2: .same(proto: "existEntranceId"),
  ]

  public var isInitialized: Bool {
    if self._lastSyncTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._lastSyncTime) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.existEntranceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._lastSyncTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if !self.existEntranceID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.existEntranceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncEntranceRequest, rhs: AutoControl_Messenger_SyncEntranceRequest) -> Bool {
    if lhs._lastSyncTime != rhs._lastSyncTime {return false}
    if lhs.existEntranceID != rhs.existEntranceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncTimeTablePointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncTimeTablePointRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSyncTime"),
    2: .same(proto: "existTimeTablePointId"),
  ]

  public var isInitialized: Bool {
    if self._lastSyncTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._lastSyncTime) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.existTimeTablePointID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._lastSyncTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if !self.existTimeTablePointID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.existTimeTablePointID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncTimeTablePointRequest, rhs: AutoControl_Messenger_SyncTimeTablePointRequest) -> Bool {
    if lhs._lastSyncTime != rhs._lastSyncTime {return false}
    if lhs.existTimeTablePointID != rhs.existTimeTablePointID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncTimeTableRoundRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncTimeTableRoundRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSyncTime"),
    2: .same(proto: "existTimeTableRoundId"),
  ]

  public var isInitialized: Bool {
    if self._lastSyncTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._lastSyncTime) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.existTimeTableRoundID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._lastSyncTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if !self.existTimeTableRoundID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.existTimeTableRoundID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncTimeTableRoundRequest, rhs: AutoControl_Messenger_SyncTimeTableRoundRequest) -> Bool {
    if lhs._lastSyncTime != rhs._lastSyncTime {return false}
    if lhs.existTimeTableRoundID != rhs.existTimeTableRoundID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncVehicleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncVehicleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicle"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.vehicle) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.vehicle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vehicle.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vehicle, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncVehicleResponse, rhs: AutoControl_Messenger_SyncVehicleResponse) -> Bool {
    if lhs.vehicle != rhs.vehicle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_VehicleProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "groupId"),
    3: .same(proto: "name"),
    4: .same(proto: "vin"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._name == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._groupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._vin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._groupID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._vin {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_VehicleProtoObject, rhs: AutoControl_Messenger_VehicleProtoObject) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._groupID != rhs._groupID {return false}
    if lhs._name != rhs._name {return false}
    if lhs._vin != rhs._vin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncGroupResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.group) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.group) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.group.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.group, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncGroupResponse, rhs: AutoControl_Messenger_SyncGroupResponse) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_GroupProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._name == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_GroupProtoObject, rhs: AutoControl_Messenger_GroupProtoObject) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncVehicleSensorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncVehicleSensorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicleSensor"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.vehicleSensor) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.vehicleSensor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vehicleSensor.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vehicleSensor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncVehicleSensorResponse, rhs: AutoControl_Messenger_SyncVehicleSensorResponse) -> Bool {
    if lhs.vehicleSensor != rhs.vehicleSensor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_VehicleSensorProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleSensorProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "vehicleId"),
    3: .same(proto: "sensorType"),
    4: .same(proto: "name"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._vehicleID == nil {return false}
    if self._sensorType == nil {return false}
    if self._name == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._vehicleID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._sensorType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._vehicleID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._sensorType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_VehicleSensorProtoObject, rhs: AutoControl_Messenger_VehicleSensorProtoObject) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._vehicleID != rhs._vehicleID {return false}
    if lhs._sensorType != rhs._sensorType {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncVehicleSensorMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncVehicleSensorMessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sensorMessage"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.sensorMessage) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sensorMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sensorMessage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sensorMessage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncVehicleSensorMessageResponse, rhs: AutoControl_Messenger_SyncVehicleSensorMessageResponse) -> Bool {
    if lhs.sensorMessage != rhs.sensorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SensorMessageProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SensorMessageProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "text"),
    3: .same(proto: "vehicleSensorId"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    if self._text == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._value) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.vehicleSensorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._value {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.vehicleSensorID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.vehicleSensorID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SensorMessageProtoObject, rhs: AutoControl_Messenger_SensorMessageProtoObject) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._text != rhs._text {return false}
    if lhs.vehicleSensorID != rhs.vehicleSensorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncDictionaryCompleteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncDictionaryCompleteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSyncTime"),
  ]

  public var isInitialized: Bool {
    if self._lastSyncTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._lastSyncTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._lastSyncTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncDictionaryCompleteResponse, rhs: AutoControl_Messenger_SyncDictionaryCompleteResponse) -> Bool {
    if lhs._lastSyncTime != rhs._lastSyncTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncSensorDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncSensorDataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.data) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncSensorDataResponse, rhs: AutoControl_Messenger_SyncSensorDataResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SensorDataProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SensorDataProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicleSensorId"),
    2: .same(proto: "dateTime"),
    3: .same(proto: "typeSensorData"),
    4: .same(proto: "valueInt"),
    5: .same(proto: "valueDouble"),
    6: .same(proto: "valueString"),
    7: .same(proto: "latitude"),
    8: .same(proto: "longitude"),
  ]

  public var isInitialized: Bool {
    if self._vehicleSensorID == nil {return false}
    if self._dateTime == nil {return false}
    if self._typeSensorData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._vehicleSensorID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._dateTime) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._typeSensorData) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._valueInt) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._valueDouble) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._valueString) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self._latitude) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self._longitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._vehicleSensorID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._dateTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._typeSensorData {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    if let v = self._valueInt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._valueDouble {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }
    if let v = self._valueString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 7)
    }
    if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SensorDataProtoObject, rhs: AutoControl_Messenger_SensorDataProtoObject) -> Bool {
    if lhs._vehicleSensorID != rhs._vehicleSensorID {return false}
    if lhs._dateTime != rhs._dateTime {return false}
    if lhs._typeSensorData != rhs._typeSensorData {return false}
    if lhs._valueInt != rhs._valueInt {return false}
    if lhs._valueDouble != rhs._valueDouble {return false}
    if lhs._valueString != rhs._valueString {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncNavigationDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncNavigationDataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.data) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncNavigationDataResponse, rhs: AutoControl_Messenger_SyncNavigationDataResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncNavigationDataProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncNavigationDataProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicleId"),
    2: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if self._vehicleID == nil {return false}
    if self._data == nil {return false}
    if let v = self._data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._vehicleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._vehicleID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncNavigationDataProtoObject, rhs: AutoControl_Messenger_SyncNavigationDataProtoObject) -> Bool {
    if lhs._vehicleID != rhs._vehicleID {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_NavigationDataProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NavigationDataProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dateTime"),
    2: .same(proto: "valid"),
    3: .same(proto: "latitude"),
    4: .same(proto: "longitude"),
    5: .same(proto: "speed"),
    6: .same(proto: "course"),
    7: .same(proto: "delta"),
    8: .same(proto: "satelliteCount"),
    9: .same(proto: "height"),
    10: .same(proto: "hdop"),
  ]

  public var isInitialized: Bool {
    if self._dateTime == nil {return false}
    if self._valid == nil {return false}
    if self._latitude == nil {return false}
    if self._longitude == nil {return false}
    if self._speed == nil {return false}
    if self._course == nil {return false}
    if self._delta == nil {return false}
    if self._satelliteCount == nil {return false}
    if self._height == nil {return false}
    if self._hdop == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._dateTime) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._valid) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._latitude) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._longitude) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._speed) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self._course) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self._delta) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._satelliteCount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self._height) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._hdop) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._dateTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._valid {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }
    if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }
    if let v = self._speed {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }
    if let v = self._course {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    }
    if let v = self._delta {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 7)
    }
    if let v = self._satelliteCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
    }
    if let v = self._hdop {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_NavigationDataProtoObject, rhs: AutoControl_Messenger_NavigationDataProtoObject) -> Bool {
    if lhs._dateTime != rhs._dateTime {return false}
    if lhs._valid != rhs._valid {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._speed != rhs._speed {return false}
    if lhs._course != rhs._course {return false}
    if lhs._delta != rhs._delta {return false}
    if lhs._satelliteCount != rhs._satelliteCount {return false}
    if lhs._height != rhs._height {return false}
    if lhs._hdop != rhs._hdop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncRouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncRouteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "route"),
    2: .same(proto: "deletedRouteId"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.route) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.route) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.deletedRouteID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.route.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.route, fieldNumber: 1)
    }
    if !self.deletedRouteID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.deletedRouteID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncRouteResponse, rhs: AutoControl_Messenger_SyncRouteResponse) -> Bool {
    if lhs.route != rhs.route {return false}
    if lhs.deletedRouteID != rhs.deletedRouteID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_RouteProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "WKT"),
    5: .same(proto: "enabled"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._name == nil {return false}
    if self._enabled == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._wkt) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._wkt {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._enabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_RouteProtoObject, rhs: AutoControl_Messenger_RouteProtoObject) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._name != rhs._name {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._wkt != rhs._wkt {return false}
    if lhs._enabled != rhs._enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncBusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncBusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bus"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.bus) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.bus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bus, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncBusResponse, rhs: AutoControl_Messenger_SyncBusResponse) -> Bool {
    if lhs.bus != rhs.bus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_BusProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BusProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "latitude"),
    4: .same(proto: "longitude"),
    5: .same(proto: "speed"),
    6: .same(proto: "course"),
    7: .same(proto: "date"),
    8: .same(proto: "routeId"),
    9: .same(proto: "entranceId"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._name == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._latitude) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._longitude) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._speed) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self._course) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self._date) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._routeID) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self._entranceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }
    if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }
    if let v = self._speed {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }
    if let v = self._course {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    }
    if let v = self._date {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    }
    if let v = self._routeID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._entranceID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_BusProtoObject, rhs: AutoControl_Messenger_BusProtoObject) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._name != rhs._name {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._speed != rhs._speed {return false}
    if lhs._course != rhs._course {return false}
    if lhs._date != rhs._date {return false}
    if lhs._routeID != rhs._routeID {return false}
    if lhs._entranceID != rhs._entranceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncEntranceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncEntranceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entrance"),
    2: .same(proto: "deletedEntranceId"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entrance) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entrance) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.deletedEntranceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entrance.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entrance, fieldNumber: 1)
    }
    if !self.deletedEntranceID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.deletedEntranceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncEntranceResponse, rhs: AutoControl_Messenger_SyncEntranceResponse) -> Bool {
    if lhs.entrance != rhs.entrance {return false}
    if lhs.deletedEntranceID != rhs.deletedEntranceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_EntranceProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntranceProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._name == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_EntranceProtoObject, rhs: AutoControl_Messenger_EntranceProtoObject) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncTimeTablePointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncTimeTablePointResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timetablePoint"),
    2: .same(proto: "deletedTimeTablePointId"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.timetablePoint) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.timetablePoint) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.deletedTimeTablePointID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timetablePoint.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timetablePoint, fieldNumber: 1)
    }
    if !self.deletedTimeTablePointID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.deletedTimeTablePointID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncTimeTablePointResponse, rhs: AutoControl_Messenger_SyncTimeTablePointResponse) -> Bool {
    if lhs.timetablePoint != rhs.timetablePoint {return false}
    if lhs.deletedTimeTablePointID != rhs.deletedTimeTablePointID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_TimeTablePointProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeTablePointProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "routePointId"),
    3: .same(proto: "entranceId"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._routePointID == nil {return false}
    if self._entranceID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._routePointID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._entranceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._routePointID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._entranceID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_TimeTablePointProtoObject, rhs: AutoControl_Messenger_TimeTablePointProtoObject) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._routePointID != rhs._routePointID {return false}
    if lhs._entranceID != rhs._entranceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncTimeTableRoundResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncTimeTableRoundResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timetableRound"),
    2: .same(proto: "deletedTimeTableRoundId"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.timetableRound) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.timetableRound) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.deletedTimeTableRoundID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timetableRound.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timetableRound, fieldNumber: 1)
    }
    if !self.deletedTimeTableRoundID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.deletedTimeTableRoundID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncTimeTableRoundResponse, rhs: AutoControl_Messenger_SyncTimeTableRoundResponse) -> Bool {
    if lhs.timetableRound != rhs.timetableRound {return false}
    if lhs.deletedTimeTableRoundID != rhs.deletedTimeTableRoundID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_TimeTableRoundProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeTableRoundProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "timeTablePointId"),
    3: .same(proto: "round"),
    4: .same(proto: "time"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._timeTablePointID == nil {return false}
    if self._round == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._timeTablePointID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._round) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._timeTablePointID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._round {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._time {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_TimeTableRoundProtoObject, rhs: AutoControl_Messenger_TimeTableRoundProtoObject) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._timeTablePointID != rhs._timeTablePointID {return false}
    if lhs._round != rhs._round {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncPointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncPointResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
    2: .same(proto: "deletedPointId"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.point) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.point) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.deletedPointID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.point.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.point, fieldNumber: 1)
    }
    if !self.deletedPointID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.deletedPointID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncPointResponse, rhs: AutoControl_Messenger_SyncPointResponse) -> Bool {
    if lhs.point != rhs.point {return false}
    if lhs.deletedPointID != rhs.deletedPointID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_PointProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PointProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "latitude"),
    4: .same(proto: "longitude"),
    5: .same(proto: "routeId"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._name == nil {return false}
    if self._latitude == nil {return false}
    if self._longitude == nil {return false}
    if self._routeID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._latitude) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._longitude) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._routeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }
    if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }
    if let v = self._routeID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_PointProtoObject, rhs: AutoControl_Messenger_PointProtoObject) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._name != rhs._name {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._routeID != rhs._routeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SyncVehicleDataCompleteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncVehicleDataCompleteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fake"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._fake) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fake {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SyncVehicleDataCompleteResponse, rhs: AutoControl_Messenger_SyncVehicleDataCompleteResponse) -> Bool {
    if lhs._fake != rhs._fake {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_TrackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicleId"),
    2: .same(proto: "dateTimeFrom"),
    3: .same(proto: "dateTimeTo"),
  ]

  public var isInitialized: Bool {
    if self._vehicleID == nil {return false}
    if self._dateTimeFrom == nil {return false}
    if self._dateTimeTo == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._vehicleID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._dateTimeFrom) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._dateTimeTo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._vehicleID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._dateTimeFrom {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._dateTimeTo {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_TrackRequest, rhs: AutoControl_Messenger_TrackRequest) -> Bool {
    if lhs._vehicleID != rhs._vehicleID {return false}
    if lhs._dateTimeFrom != rhs._dateTimeFrom {return false}
    if lhs._dateTimeTo != rhs._dateTimeTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_TrackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicleId"),
    2: .same(proto: "data"),
    3: .same(proto: "currentNumberEvent"),
    4: .same(proto: "totalAmountEvent"),
  ]

  public var isInitialized: Bool {
    if self._vehicleID == nil {return false}
    if self._currentNumberEvent == nil {return false}
    if self._totalAmountEvent == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.data) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._vehicleID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._currentNumberEvent) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._totalAmountEvent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._vehicleID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    if let v = self._currentNumberEvent {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._totalAmountEvent {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_TrackResponse, rhs: AutoControl_Messenger_TrackResponse) -> Bool {
    if lhs._vehicleID != rhs._vehicleID {return false}
    if lhs.data != rhs.data {return false}
    if lhs._currentNumberEvent != rhs._currentNumberEvent {return false}
    if lhs._totalAmountEvent != rhs._totalAmountEvent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_TrackProtoObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackProtoObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sensorData"),
    2: .same(proto: "navigationData"),
  ]

  fileprivate class _StorageClass {
    var _sensorData: AutoControl_Messenger_SensorDataProtoObject? = nil
    var _navigationData: AutoControl_Messenger_NavigationDataProtoObject? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sensorData = source._sensorData
      _navigationData = source._navigationData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sensorData, !v.isInitialized {return false}
      if let v = _storage._navigationData, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._sensorData) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._navigationData) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sensorData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._navigationData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_TrackProtoObject, rhs: AutoControl_Messenger_TrackProtoObject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sensorData != rhs_storage._sensorData {return false}
        if _storage._navigationData != rhs_storage._navigationData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_SensorDataEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SensorDataEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if self._data == nil {return false}
    if let v = self._data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_SensorDataEvent, rhs: AutoControl_Messenger_SensorDataEvent) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_NavigationDataEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NavigationDataEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicleId"),
    2: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if self._vehicleID == nil {return false}
    if self._data == nil {return false}
    if let v = self._data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._vehicleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._vehicleID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_NavigationDataEvent, rhs: AutoControl_Messenger_NavigationDataEvent) -> Bool {
    if lhs._vehicleID != rhs._vehicleID {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_VehicleConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.data) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_VehicleConnectResponse, rhs: AutoControl_Messenger_VehicleConnectResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoControl_Messenger_VehicleConnectEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleConnectEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicleId"),
    2: .same(proto: "connect"),
  ]

  public var isInitialized: Bool {
    if self._vehicleID == nil {return false}
    if self._connect == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._vehicleID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._connect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._vehicleID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._connect {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoControl_Messenger_VehicleConnectEvent, rhs: AutoControl_Messenger_VehicleConnectEvent) -> Bool {
    if lhs._vehicleID != rhs._vehicleID {return false}
    if lhs._connect != rhs._connect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
